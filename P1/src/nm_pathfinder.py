from queue import *from math import sqrtfrom heapq import heappush, heappopdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # path, boxes = BFS(source_point, destination_point, mesh)    path, boxes = dijkstras(source_point, destination_point, mesh)    if not path:        print("No path!")    return path, boxes.keys()def BFS(src, dst, mesh):    """    Runs a breadth first search on the provided mesh.    May be used to make sure that the implementation of other search algorithms accurately report    the existence of a path    """    src_box, dst_box = find_boxes(src, dst, mesh)    path = []    boxes = {src_box: src, dst_box: dst}    frontier = Queue()    frontier.put(src_box)    came_from = {src_box: None}    while not(frontier.empty()):        b = frontier.get()        if b == dst_box:            path.append(dst)  # Add the destination point to the path first            while not (b is None):                path.append(boxes[b])                b = came_from[b]            return path, boxes        for c in mesh['adj'][b]:            if not (c in came_from):                boxes[c] = get_detail_point(boxes[b], c)                came_from[c] = b                frontier.put(c)    return path, boxesdef dijkstras(src, dst, mesh):    """    Based on the provided implementation of Dijkstra's algorithm.    Modified to work with the input mesh object.    """    src_box, dst_box = find_boxes(src, dst, mesh)    path = []    boxes = {src_box: src, dst_box: dst}    frontier = []    heappush(frontier, (0, src_box))    came_from = {src_box: None}    dist_so_far = {src_box: 0}    while frontier:        priority, b = heappop(frontier)        if b == dst_box:            path.append(dst)            while not (b is None):                path.append(boxes[b])                b = came_from[b]            return path, boxes        for c in mesh['adj'][b]:            entry_point = get_detail_point(boxes[b], c)            dist_to_child = priority + distance(boxes[b], entry_point)            if not (c in came_from) or dist_to_child < dist_so_far[c]:                boxes[c] = entry_point                came_from[c] = b                dist_so_far[c] = dist_to_child                heappush(frontier, (dist_to_child, c))    return path, boxesdef get_detail_point(current_pt, next_box):    x = min(max(current_pt[0], next_box[0]), next_box[1])    y = min(max(current_pt[1], next_box[2]), next_box[3])    return x, ydef distance(a, b):    return sqrt(((b[0] - a[0]) ** 2) + ((b[1] - a[1]) ** 2))def find_boxes(src, dst, mesh):    start_box = None    end_box = None    for box in mesh['boxes']:        if start_box is None and box[0] <= src[0] <= box[1] and box[2] <= src[1] <= box[3]:            start_box = box        if end_box is None and box[0] <= dst[0] <= box[1] and box[2] <= dst[1] <= box[3]:            end_box = box        if not (start_box is None or end_box is None):            break    return start_box, end_box